#+TITLE: Credimi Test Coverage Improvements
#+SUBTITLE: Improve Go unit coverage visibility, expand low-friction tests, and add CI signals (repo-only)
#+DATE: 2026-01-30
#+KEYWORDS: tests, coverage, ci, go, pocketbase, temporal, sveltekit, vitest, playwright, regression

* DONE [#A] Confirm scope and define “coverage” success criteria
- Effort :: XS
- Goal :: Decide whether we are improving test *quantity* (more cases), *execution* (ensure they run in CI), or *visibility* (coverage reporting) for `credimi.git`.
- Notes :: `credimi.git` contains a PocketBase-backed Go API + Temporal workflows (`pkg/`) and a SvelteKit webapp (`webapp/`). The repo already distinguishes “unit” vs “non-unit” via build tags (some Go tests are `//go:build !unit`).
** DONE [#A] Clarify what you mean by “better coverage”
- Why :: “Coverage” could mean go test statement coverage, route/workflow behavior coverage, or just ensuring all existing tests run reliably in CI and locally.
- Change ::
  - Decide primary objective(s) for this repo:
    - Option A (recommended first): make Go unit test coverage *visible* (repeatable local + CI reporting) and add low-friction unit tests in packages that currently have none.
    - Option B: expand webapp confidence (Vitest unit tests + Playwright E2E) and run at least unit tests in CI.
    - Option C: add “integration” coverage for Temporal-dependent handlers/workflows (likely `!unit` or a new `integration` tag), but only if CI can provide Temporal and we accept longer runtimes.
  - Capture “Done when” metrics (pick 2–3):
    - `make test` and CI run the same Go unit suite (`--tags=unit`) and fail on regressions.
    - CI uploads a Go coverage artifact and prints a coverage summary table.
    - Webapp unit tests run in CI on `webapp/**` changes (E2E optional / non-blocking at first).
- Tests :: N/A (decision)
- Done when :: We have an agreed scope and 2–3 measurable success criteria.
- Decision :: Objective A (Go unit coverage visibility + low-friction tests). Done when: coverage artifact + summary in CI logs (CI handled manually).



* WIP [#A] Make Go unit coverage visible and reliable (no new deps)
- Effort :: S
- Goal :: Provide a feedback loop for Go tests: generate a coverage profile for the unit suite and publish a summary in CI.
- Notes :: Current state:
  - `make test` is labeled “run tests with coverage” but does not emit a `coverprofile`.
  - `make coverage` runs `go test -coverprofile=coverage.out` without `--tags=unit`, and passes `--tags=unit` to `go tool cover -html` (likely an invalid/ignored flag). This makes “coverage” numbers hard to trust.
** DONE [#A] Standardize local coverage commands for the unit suite
- Why :: We need a stable, repeatable baseline number before we can improve it.
- Change ::
  - Define a single canonical command line for Go unit coverage, e.g.:
    - `go test -tags=unit -covermode=atomic -coverprofile=tmp/coverage/go-unit.out ./...`
  - Decide whether to use `-coverpkg=./...` (slower, but measures cross-package coverage) or keep default per-package.
  - Ensure the command matches `make test` scope (currently `./pkg/... ./cmd/...`) to avoid “missing packages” surprises.
- Tests :: Run in CI; verify coverage file exists and `go tool cover -func` prints a summary.
- Done when :: A developer can run one command locally and get the same unit coverage summary as CI.
** TODO [#B] Add CI coverage artifacts and a human-readable summary
- Why :: Coverage is only useful if it is visible during PR review.
- Change ::
  - Extend `.github/workflows/go.yml` test job to also run the coverage command and:
    - upload the `coverprofile` as an artifact (name includes commit SHA/job),
    - print `go tool cover -func` totals to the log.
  - Keep it non-blocking initially (no gating) until a baseline is established.
- Tests :: CI workflow completes and artifacts are present.
- Done when :: Every PR shows a coverage summary in CI logs and stores the raw profile for deeper inspection.
** TODO [#C] Decide whether to gate coverage (and how)
- Why :: Gating prevents gradual erosion but can be noisy early on.
- Change ::
  - Options:
    - Soft gate: report only (baseline + deltas if we add a script later).
    - Hard gate: “no decrease” or minimum threshold (per-package or total).
  - Choose one and document rationale.
- Tests :: N/A (policy)
- Done when :: A gating policy is written down and enforced (or explicitly deferred).

* TODO [#A] Baseline: inventory current tests, tags, and obvious gaps (repo-only)
- Effort :: XS
- Goal :: Make the current test surface and biggest gaps explicit so we add tests where they reduce risk.
- Notes :: Current inventory (from repo contents):
  - Go: ~62 `*_test.go` files under `pkg/` + `cmd/`. `make test` runs `go test ./pkg/... ./cmd/... --tags=unit` (no coverage profile is currently produced by that target).
  - Go “non-unit”: only a few tests are explicitly excluded from unit runs via `//go:build !unit` (e.g., some workflow/activity tests); at least one such file is commented out as “OLD TESTS BROKEN RIGHT NOW”.
  - Webapp: Playwright E2E exists (~5 specs), but Vitest unit tests are minimal (~1 file). Webapp tests are not currently run in GitHub Actions.
** TODO [#A] Write down the test taxonomy and what runs where
- Why :: Without a clear contract, adding tests tends to create flake (integration sneaking into unit) or dead tests (never run in CI).
- Change ::
  - Document (in `README.md` or `CRUSH.md`) the intended suites:
    - Go unit: `make test` (must be deterministic; no external services; `--tags=unit`).
    - Go integration (optional): `go test ./...` (no `--tags=unit`) to include existing `//go:build !unit` tests, or adopt a new explicit `integration` tag, only when CI/local provide infra (Temporal, Docker, etc.).
    - Webapp unit: `cd webapp && bun run test:unit -- --run`.
    - Webapp E2E: `cd webapp && bun run test:e2e` (likely opt-in / path-filtered in CI).
  - Call out existing `!unit` tests and whether they are expected to be kept, fixed, or removed.
- Tests :: N/A (documentation)
- Done when :: The repo docs state exactly which test suites exist, how to run them, and which are CI-blocking.
** TODO [#B] Enumerate “low-friction” untested areas to target first
- Why :: Adding tests is easiest (and least disruptive) where logic is pure, inputs/outputs are stable, and IO is already abstracted.
- Change ::
  - Prioritize packages that currently have Go code but no `*_test.go` in the same directory:
    - `pkg/workflowengine/` (root helpers like scheduling, error shaping)
    - `pkg/internal/routing/` (validated input + route registration glue)
    - `pkg/routes/` (reverse proxy behavior)
    - `pkg/internal/pb/` (some unit-testable helpers, some Temporal IO)
    - `pkg/workflowengine/hooks/`, `pkg/workflowengine/registry/`, `pkg/workflowengine/mobilerunnersemaphore/`
    - CLI commands under `cmd/cli/`, plus `cmd/seeds/` and `cmd/template/`
  - Prioritize handler files with routes but no direct tests:
    - `pkg/internal/apis/handlers/checks_handlers.go`
    - `pkg/internal/apis/handlers/schedules_handlers.go`
    - `pkg/internal/apis/handlers/start_conformance_check_handler.go`
    - `pkg/internal/apis/handlers/utility.go` (DB lookups)
    - plus `canonify.go`, `deeplink_handler.go`, `compliance_handlers.go`, `conformance_check_handlers.go`
- Tests :: N/A (inventory)
- Done when :: We have a ranked list (top ~10) of test additions that don’t require refactors or new infra.

* TODO [#A] Add low-friction Go unit tests (no big refactors)
- Effort :: M
- Goal :: Increase behavior coverage in packages where tests are currently missing or thin, using existing patterns (table-driven tests + `stretchr/testify`).
- Notes :: Preference order:
  1) pure functions / deterministic transformations,
  2) validation and error-mapping branches that run before external IO,
  3) integration tests only when infra is available and explicit.
** TODO [#A] Add tests for `pkg/workflowengine/schedule.go` (spec building + parsing)
- Why :: Scheduling logic is subtle (month length, weekly/day defaults) and currently untested in the `workflowengine` root package.
- Change ::
  - Add `pkg/workflowengine/schedule_test.go` covering:
    - `BuildCalendarSpec` invariants for `daily`, `weekly`, `monthly` (assert structural ranges; avoid asserting `time.Now()` derived second/minute/hour values).
    - Monthly edge cases: `Day` near end-of-month (e.g., 28–30) generates 12 month-specific specs and clamps for 30-day months / February.
    - `ParseScheduleMode` classification for calendars that represent weekly/monthly schedules.
  - Treat test failures as signals of a logic bug (expected to be fixed in follow-up work, not papered over).
- Tests :: `make test`
- Done when :: Unit tests describe and lock the intended schedule semantics and catch regressions.
** TODO [#B] Add tests for `pkg/workflowengine/utils.go` and `pkg/workflowengine/activity.go` (error shaping + helpers)
- Why :: These helpers affect workflow correctness and error surfaces; they’re cheap to test and high ROI.
- Change ::
  - Add `pkg/workflowengine/utils_test.go` for:
    - `DecodePayload` (valid decode, invalid schema/validation, marshal/unmarshal failures via bad inputs),
    - `AsSliceOfMaps`/`AsSliceOfStrings`/`AsString`/`AsMap`/`AsBool` edge cases.
  - Add `pkg/workflowengine/activity_test.go` for:
    - `BaseActivity.NewActivityError` payload flattening behavior,
    - `BaseActivity.NewNonRetryableActivityError` type/message invariants.
  - Optional (if stable across CI runners): `RunCommandWithCancellation` cancellation behavior using a short-lived command.
- Tests :: `make test`
- Done when :: The helpers’ observable behavior is locked by tests (especially around error details).
** TODO [#B] Add tests for `pkg/internal/routing/routing.go` (validated input + route registration)
- Why :: Routing/validation glue affects every API endpoint; small mistakes become systemic bugs.
- Change ::
  - Add `pkg/internal/routing/routing_test.go` covering:
    - `GetValidatedInput[T]` behavior for nil, correct type, and type mismatch (ensuring mismatch maps to a 500 JSON API error via `apierror`).
    - `RegisterRoutesWithValidation` invariants:
      - `apis.RequireAuth()` binding when `needsAuth=true`,
      - validation middleware is bound for body methods when `RequestSchema != nil`,
      - excluded middlewares are unbound as specified.
  - Reuse PocketBase routing primitives if they can be instantiated in tests; otherwise, test at a slightly higher level via existing handler route registration patterns.
- Tests :: `make test`
- Done when :: A refactor in routing/validation can’t silently break auth or validation binding.
** TODO [#B] Add tests for `pkg/routes/routes.go` (reverse proxy director behavior)
- Why :: The UI reverse proxy is critical and easy to break; header behavior is part of the deployment contract.
- Change ::
  - Add `pkg/routes/routes_test.go` focusing on `createReverseProxy`:
    - correct scheme/host rewriting,
    - Host header and X-Forwarded-For set,
    - Origin/Referer preservation,
    - handles malformed `ADDRESS_UI` (via `url.Parse`) predictably.
- Tests :: `make test`
- Done when :: Proxy behavior is regression-protected without needing to boot the whole server.
** TODO [#B] Add tests for core error contracts (`pkg/internal/apierror`, `pkg/internal/errorcodes`)
- Why :: These types underpin the API’s error response contract and workflow error typing.
- Change ::
  - Add `pkg/internal/apierror/apierror_test.go` for `Error()` formatting and JSON status behavior.
  - Add `pkg/internal/errorcodes/errorcodes_test.go` to ensure:
    - every `const` code exists in `Codes`,
    - no missing/empty descriptions,
    - optional: no duplicate code strings across entries.
- Tests :: `make test`
- Done when :: Error codes and messages can’t drift without failing tests.
** TODO [#B] Add CLI tests for `cmd/cli/` (schema + pipeline) using `httptest`
- Why :: CLI is user-facing and currently lacks tests; much of it can be covered without hitting real networks or Temporal.
- Change ::
  - Add `cmd/cli/schema_test.go` to validate `generatePipelineSchema`:
    - includes `$defs.ActivityOptions`,
    - `steps.items.oneOf` contains registry step variants + special cases,
    - output stability (sorting of registry keys).
  - Add `cmd/cli/pipeline_test.go` to validate:
    - `parsePipelineName` YAML parsing (success/failure),
    - `findOrCreatePipeline` behavior using an `httptest.Server` (find-hit vs create path, error mapping).
- Tests :: `make test`
- Done when :: Core CLI behavior is covered without external dependencies.
** TODO [#B] Add unit tests for workflow registries and ID helpers (`registry`, `mobilerunnersemaphore`)
- Why :: These are central lookup/identity utilities; mistakes cause runtime failures that are hard to diagnose.
- Change ::
  - Add `pkg/workflowengine/registry/registry_test.go` to validate invariants:
    - every `TaskFactory` has a non-nil `NewFunc`,
    - `Kind` is one of the defined enum values,
    - activity entries have a non-nil `PayloadType` and a sensible `OutputKind`,
    - denylist keys exist in the main registry (no stale entries).
  - Add `pkg/workflowengine/mobilerunnersemaphore/types_test.go` to validate:
    - `WorkflowID(runnerID)` formatting,
    - `PermitLeaseID(workflowID, runID, runnerID)` uniqueness and separator behavior.
- Tests :: `make test`
- Done when :: Registry/ID invariants are protected against accidental edits.
** TODO [#C] Add a unit test for `pkg/workflowengine/hooks.FetchNamespaces` using fixtures
- Why :: Namespace enumeration influences worker startup; it is deterministic given the DB state.
- Change ::
  - Add `pkg/workflowengine/hooks/hook_test.go` focusing only on `FetchNamespaces`:
    - returns `default` plus all org `canonified_name` values from fixtures,
    - handles empty org list.
  - Reuse `fixtures/test_pb_data` (avoid creating ad-hoc DB state unless needed).
- Tests :: `make test`
- Done when :: Worker namespace enumeration is regression-protected without needing Temporal.
** TODO [#C] Add smoke-level tests for `cmd/seeds/` and `cmd/template/` where feasible
- Why :: These commands can affect developer environments and databases; minimal regression coverage helps.
- Change ::
  - Add `cmd/seeds/seed_test.go` in package `main` to cover the JSON parsing compatibility paths (ordered list vs legacy map) and “missing collection skips” behavior, using a minimal PocketBase test app if available in existing dependencies.
  - For `cmd/template/`, add unit tests only for pure helpers (avoid end-to-end file IO unless already deterministic).
- Tests :: `make test`
- Done when :: These commands have basic guardrails without needing large refactors.

* TODO [#B] Add targeted unit tests for PocketBase/Temporal glue that is already unit-testable
- Effort :: S
- Goal :: Cover “glue” code paths that don’t require a live Temporal server by using fakes/stubs and short-circuit branches.
- Notes :: The repo has some Temporal-heavy hooks; focus on helpers that already accept interfaces (or error before IO) to avoid refactors.
** TODO [#B] Add tests for `pkg/internal/pb/namespaces.go` namespace readiness helper
- Why :: Namespace creation/readiness is race-prone; the helper already accepts a `client.NamespaceClient` interface, making it testable without Temporal.
- Change ::
  - Add `pkg/internal/pb/namespaces_test.go` for `waitForNamespaceReady`:
    - succeeds immediately when `Describe` returns nil,
    - retries on transient errors until success,
    - returns last error on timeout (use short timeouts in tests).
  - Use a fake `client.NamespaceClient` implementation in the test package (no new deps).
- Tests :: `make test`
- Done when :: Retry/backoff logic is regression-protected without requiring a Temporal server.
** TODO [#B] Add tests for `pkg/internal/pb/schedules.go` “pre-Temporal” error branches
- Why :: The hook mutates records on enrich; even without Temporal, we can validate that missing owner/collection errors are surfaced correctly.
- Change ::
  - Add `pkg/internal/pb/schedules_test.go` that triggers the enrich handler with:
    - missing/invalid `owner` → returns “failed to fetch owner organization” error,
    - missing `temporal_schedule_id` (if it fails before Temporal) → assert safe error behavior.
  - Avoid asserting Temporal response fields; stop at pre-Temporal gates.
- Tests :: `make test`
- Done when :: Hook failures are deterministic and caught early by unit tests.

* TODO [#B] Add low-friction API/handler tests that don’t require Temporal runtime
- Effort :: M
- Goal :: Increase confidence in request validation, auth, DB lookups, and error mapping for handlers that currently lack direct tests.
- Notes :: Many handlers call Temporal early; focus on paths that short-circuit before Temporal IO (bad inputs, missing auth, missing records). For Temporal-dependent behavior, defer to explicit integration tests later.
** TODO [#B] Add tests for `pkg/internal/apis/handlers/utility.go` (organization lookups)
- Why :: These helpers back many handlers and are deterministic with test DB fixtures.
- Change ::
  - Add `pkg/internal/apis/handlers/utility_test.go` using the existing PocketBase test app + `fixtures/test_pb_data`:
    - `GetUserOrganizationID` happy path and “missing auth”/missing record error path,
    - `GetUserOrganizationCanonifiedName` happy path and missing org.
  - Ensure error cases are asserted (not just non-nil).
- Tests :: `make test`
- Done when :: Organization lookup logic is regression-protected.
** TODO [#B] Add tests for validation-only branches in Temporal-touching handlers
- Why :: Even if we can’t unit-test Temporal calls, we can and should lock down “input gatekeeping” and error mapping.
- Change ::
  - Add `pkg/internal/apis/handlers/schedules_handlers_test.go` for:
    - `validateScheduleMode` bounds/defaulting behavior (weekly/monthly),
    - request decode failure returns 400.
  - Add `pkg/internal/apis/handlers/start_conformance_check_handler_test.go` for:
    - missing `id` query param → 400,
    - invalid `checkName` (regex) → 400,
    - path traversal attempts in `id` → 400 (ensuring early rejection).
  - Add `pkg/internal/apis/handlers/checks_handlers_test.go` for:
    - missing `e.Auth` → 401 paths (guards), and basic path-param validation where present.
- Tests :: `make test`
- Done when :: These handlers have baseline unit coverage without needing Temporal in the test environment.
** TODO [#C] Decide whether to add explicit integration tests for Temporal-backed endpoints
- Why :: End-to-end correctness (Temporal schedule creation, workflow listing/history) can’t be fully validated with unit tests alone.
- Change ::
  - If desired, add a separate suite/job that brings up Temporal (e.g., via `docker-compose`) and runs:
    - `go test ./...` (no `--tags=unit`) for the relevant packages, or
    - a new `integration` build tag for Temporal-requiring tests.
  - Keep this opt-in until stability and runtime cost are understood.
- Tests :: CI integration job (separate from unit).
- Done when :: Integration tests exist, are stable, and have a clear run contract.

* TODO [#B] Expand webapp tests (unit + E2E) without new dependencies by default
- Effort :: M
- Goal :: Increase confidence in the SvelteKit UI by adding more unit tests and targeted Playwright E2E coverage, and ensure at least unit tests run in CI.
- Notes :: Webapp currently has Playwright E2E specs but very few Vitest unit tests; CI does not run them. Vitest coverage numbers likely require adding a provider package (explicit decision needed).
** TODO [#B] Add Vitest unit tests for pure TS modules (zod/effect/utils)
- Why :: Unit tests are fast and stable; they catch most regressions in parsing/validation/business rules without needing a browser.
- Change ::
  - Add tests under `webapp/src/**` for:
    - zod schemas and transformations in `webapp/src/modules/pocketbase/zod-schema/`,
    - URL/query helpers and request builders,
    - role/feature resolution logic (generated lists), and any `effect`-based flows where determinism is high.
  - Prefer testing pure modules over Svelte components first (lowest friction).
- Tests :: `cd webapp && bun run test:unit -- --run`
- Done when :: The unit test suite covers core pure logic and runs consistently.
** TODO [#B] Add Playwright E2E coverage for 1–2 critical user journeys
- Why :: E2E tests protect against wiring failures between UI ↔ API and routing/redirect regressions.
- Change ::
  - Add 1–2 new specs under `webapp/e2e/` focusing on high-value flows already supported by fixtures, e.g.:
    - login/session redirect behavior (if present),
    - organization/pipeline list pages render with seeded data,
    - basic CRUD happy path where the backend routes are stable.
  - Keep E2E deterministic: use existing fixtures and stable selectors; avoid time-based waits.
- Tests :: `cd webapp && bun run test:e2e -- webapp/e2e/<new>.spec.ts`
- Done when :: New E2E tests add coverage without introducing flakiness.
** TODO [#C] Add CI jobs to run webapp unit tests (E2E optional)
- Why :: Tests that aren’t in CI don’t prevent regressions on PRs.
- Change ::
  - Extend GitHub Actions workflows to run:
    - `cd webapp && bun i && bun run test:unit -- --run` on changes under `webapp/**`.
  - Decide whether Playwright E2E runs:
    - on-demand / nightly, or
    - on PRs that touch critical UI routing/auth code.
- Tests :: CI green on both Go and webapp pipelines.
- Done when :: Webapp unit tests run in CI with path filters; E2E policy is explicit.

* TODO [#C] Maintenance: keep tests fast, readable, and trustworthy
- Effort :: S
- Goal :: Ensure the test suite remains a net productivity gain (low flake, clear failures, small runtime).
- Notes :: Avoid over-engineering: prefer a few high-value tests per module over extensive mocking frameworks; keep unit tests deterministic and integration tests explicit.
** TODO [#C] Establish test-writing conventions for this repo
- Why :: Consistency makes tests easier to add and maintain.
- Change ::
  - Go: table-driven tests, `require`/`assert` from `stretchr/testify`, clear naming (`TestX_Y`).
  - Webapp: prefer pure-module unit tests; keep E2E selectors stable (data-testid if already used).
  - Define how to structure fixtures (`fixtures/test_pb_data`) and when to add new ones.
- Tests :: N/A (conventions)
- Done when :: Contributors can follow a short “how to add tests” section and produce consistent tests.
