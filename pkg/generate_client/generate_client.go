// SPDX-FileCopyrightText: 2025 Forkbomb BV
//
// SPDX-License-Identifier: AGPL-3.0-or-later

package main

import (
	"bytes"
	"encoding/json" 
	"fmt"
	"log"
	"os"
	"path"
	"reflect"
	"regexp"
	"runtime"
	"strings"
	"text/template"

	"gopkg.in/yaml.v3"

	"github.com/hypersequent/zen"

	api "github.com/forkbombeu/credimi/pkg/internal/apis"
	"github.com/forkbombeu/credimi/pkg/internal/apis/handlers"
	"github.com/forkbombeu/credimi/pkg/internal/apierror"
	"github.com/invopop/jsonschema"
)

// =================================================================
// =============== DATA STRUCTURES 
// =================================================================

type RouteInfo struct {
	FuncName      string
	Method        string
	GoHandlerName string
	Path          string
	InputType     string
	OutputType    string
	InputSchema   string
	OutputSchema  string
	PathParams    []string
	HasInputBody  bool
	Summary       string
	Description   string
	Tags          []string
}

type TemplateData struct {
	Schemas string
	Routes  []RouteInfo
}

type (
	OpenAPI struct {
		OpenAPI    string               `json:"openapi" yaml:"openapi"`
		Info       Info                 `json:"info" yaml:"info"`
		Servers    []Server             `json:"servers,omitempty" yaml:"servers,omitempty"`
		Paths      map[string]*PathItem `json:"paths" yaml:"paths"`
		Components Components           `json:"components" yaml:"components"`
	}
	Server struct {
		URL         string `json:"url" yaml:"url"`
		Description string `json:"description,omitempty" yaml:"description,omitempty"`
	}
	Info struct {
		Title       string  `json:"title" yaml:"title"`
		Version     string  `json:"version" yaml:"version"`
		Description string  `json:"description" yaml:"description"`
		Contact     Contact `json:"contact,omitempty" yaml:"contact,omitempty"`
	}
	Contact struct {
		Name  string `json:"name,omitempty" yaml:"name,omitempty"`
		Email string `json:"email,omitempty" yaml:"email,omitempty"`
		URL   string `json:"url,omitempty" yaml:"url,omitempty"`
	}
	PathItem struct {
		Get    *Operation `json:"get,omitempty" yaml:"get,omitempty"`
		Post   *Operation `json:"post,omitempty" yaml:"post,omitempty"`
		Put    *Operation `json:"put,omitempty" yaml:"put,omitempty"`
		Patch  *Operation `json:"patch,omitempty" yaml:"patch,omitempty"`
		Delete *Operation `json:"delete,omitempty" yaml:"delete,omitempty"`
	}
	Operation struct {
		Tags        []string            `json:"tags,omitempty" yaml:"tags,omitempty"`
		Summary     string              `json:"summary" yaml:"summary"`
		Description string              `json:"description,omitempty" yaml:"description,omitempty"`
		OperationID string              `json:"operationId" yaml:"operationId"`
		Parameters  []Parameter         `json:"parameters,omitempty" yaml:"parameters,omitempty"`
		RequestBody *RequestBody        `json:"requestBody,omitempty" yaml:"requestBody,omitempty"`
		Responses   map[string]Response `json:"responses" yaml:"responses"`
	}
	Parameter struct {
		Name        string             `json:"name" yaml:"name"`
		In          string             `json:"in" yaml:"in"`
		Description string             `json:"description,omitempty" yaml:"description,omitempty"`
		Required    bool               `json:"required" yaml:"required"`
		Schema      *jsonschema.Schema `json:"schema" yaml:"schema"`
	}
	RequestBody struct {
		Description string             `json:"description,omitempty" yaml:"description,omitempty"`
		Required    bool               `json:"required" yaml:"required"`
		Content     map[string]Content `json:"content" yaml:"content"`
	}
	Content struct {
		Schema Ref `json:"schema" yaml:"schema"`
	}
	Response struct {
		Description string             `json:"description" yaml:"description"`
		Content     map[string]Content `json:"content,omitempty" yaml:"content,omitempty"`
	}
	Ref struct {
		Ref string `json:"$ref" yaml:"$ref"`
	}
	Components struct {
		Schemas map[string]*jsonschema.Schema `json:"schemas" yaml:"schemas"`
	}
)

const tsTemplate = `// SPDX-FileCopyrightText: 2025 Forkbomb BV
//
// SPDX-License-Identifier: AGPL-3.0-or-later

// Generated by api-generator; DO NOT EDIT.
/* eslint-disable */
import { z } from "zod";
import type PocketBase from "pocketbase";

// =================================================================
// =============== SCHEMAS, TYPES & ERROR HANDLING
// =================================================================

{{.Schemas}}

/**
 * CredimiClientError is a custom error class for typed API errors.
 */
export class CredimiClientError extends Error {
    public readonly data: APIError;

    constructor(errorData: APIError) {
        super(errorData.Message || 'An API error occurred');
        this.name = 'CredimiClientError';
        this.data = errorData;
    }
}

// =================================================================
// =============== API CLIENT CLASS
// =================================================================

/**
 * Interface for options when sending requests.
 */
interface SendOptions {
    method?: string;
    body?: any;
    params?: { [key: string]: any };
    [key: string]: any;
}

export class CredimiClient {
    constructor(public pb: PocketBase) {}
{{range .Routes}}
    /**
     * {{.Summary}}
	 * {{.Description}}
     * @method {{.Method}}
     * @path {{.Path}}
     */
    async {{.FuncName}}({{. | formatInputArg}}): Promise<{{.OutputType}}> {
        const path = ` + "`" + `{{.Path | toTemplateLiteral}}` + "`;" + `

        const options: SendOptions = { method: "{{.Method}}" };

        {{if .HasInputBody -}}
        options.body = {{.InputSchema}}.parse(input);
        {{- else if .InputType}}
        options.params = {{.InputSchema}}.parse(input);
        {{- end}}

        try {
            const result = await this.pb.send(path, options);
						{{if .OutputSchema -}}
            return {{.OutputSchema}}.parse(result);
						{{- else -}}
						return result; // No output type defined
						{{- end}}
        } catch (error: any) {
            if (error && error.data) {
                const parsedError = APIErrorSchema.safeParse(error.data);
                if (parsedError.success) {
                    throw new CredimiClientError(parsedError.data);
                }
            }
            throw error;
        }
    }
{{end}}
}
`

// =================================================================
// =============== MAIN LOGIC
// =================================================================

func main() {
	log.Println("Starting API generation...")

	routeGroups := api.RouteGroups
	if len(routeGroups) == 0 {
		log.Fatal("FATAL: No route groups found. Did you register them in api.AllRouteGroups using an init() function?")
	}

	var routes []RouteInfo
	typesToProcess := make(map[string]interface{})

	typesToProcess["APIError"] = apierror.APIError{}

	log.Println("Processing routes...")
	for _, group := range routeGroups {
		for _, route := range group.Routes {
			description := route.Description
			// if description == "" {
			// 	description = route.Summary
			// }

			r := RouteInfo{
				Method:        route.Method,
				Path:          path.Join(group.BaseURL, route.Path),
				GoHandlerName: getFuncName(route.Handler),
				Summary:       route.Summary,
				Description:   description,
				// Tags:          route.Tags,
			}

			if route.Input != nil {
				typeName := reflect.TypeOf(route.Input).Name()
				if instance, ok := handlers.TypeRegistry[typeName]; ok {
					typesToProcess[typeName] = instance
					r.InputType = typeName
					r.InputSchema = typeName + "Schema"
				} else {
					log.Fatalf("FATAL: Input type '%s' is used in a route but not found in api/handlers/registry.go.", typeName)
				}
			}

			if route.Output != nil {
				typeName := reflect.TypeOf(route.Output).Name()
				if instance, ok := handlers.TypeRegistry[typeName]; ok {
					typesToProcess[typeName] = instance
					r.OutputType = typeName
					r.OutputSchema = typeName + "Schema"
				} else {
					log.Fatalf("FATAL: Output type '%s' is used in a route but not found in api/handlers/registry.go.", typeName)
				}
			} else {
				r.OutputType = "any"
				r.OutputSchema = "unknown"
			}

			r.FuncName = handlerToFuncName(r.GoHandlerName)
			r.PathParams = extractPathParams(r.Path)
			r.HasInputBody = r.InputType != "" && (r.Method == "POST" || r.Method == "PUT" || r.Method == "PATCH")
			routes = append(routes, r)
		}
	}

	log.Println("Generating TypeScript client...")
	generateTSClient(routes, typesToProcess)

	log.Println("Generating OpenAPI YAML documentation...")
	generateOpenAPIYAML(routes, typesToProcess)

	log.Println("âœ… Generation complete.")
}

// =================================================================
// =============== GENERATOR FUNCTIONS
// =================================================================


func generateTSClient(routes []RouteInfo, typesToProcess map[string]interface{}) {
	converter := zen.NewConverterWithOpts()
	for _, instance := range typesToProcess {
		converter.AddType(instance)
	}
	schemaOutput := converter.Export()

	templateData := TemplateData{Schemas: schemaOutput, Routes: routes}
	funcMap := template.FuncMap{
		"formatInputArg": func(r RouteInfo) string {
			if r.InputType == "" && len(r.PathParams) == 0 {
				return ""
			}
			var parts []string
			if r.InputType != "" {
				parts = append(parts, r.InputType)
			}
			if len(r.PathParams) > 0 {
				paramDefs := make([]string, len(r.PathParams))
				for i, p := range r.PathParams {
					paramDefs[i] = fmt.Sprintf("%s: string", p)
				}
				parts = append(parts, fmt.Sprintf("{ %s }", strings.Join(paramDefs, ", ")))
			}
			return fmt.Sprintf("input: %s", strings.Join(parts, " & "))
		},
		"toTemplateLiteral": func(p string) string {
			re := regexp.MustCompile(`{([^{}]+)}`)
			return re.ReplaceAllString(p, "${input.$1}")
		},
	}

	tmpl, err := template.New("ts").Funcs(funcMap).Parse(tsTemplate)
	if err != nil {
		log.Fatalf("FATAL: Failed to parse template: %v", err)
	}

	var buf bytes.Buffer
	if err := tmpl.Execute(&buf, templateData); err != nil {
		log.Fatalf("FATAL: Failed to execute template: %v", err)
	}

	outputPath := "../webapp/src/lib/credimiClient.ts"
	if err := os.WriteFile(outputPath, buf.Bytes(), 0644); err != nil {
		log.Fatalf("FATAL: Failed to write output file '%s': %v", outputPath, err)
	}
	log.Printf("âœ… TypeScript client successfully generated at: %s", outputPath)
}

func generateOpenAPIYAML(routes []RouteInfo, typesToProcess map[string]interface{}) {
	reflector := new(jsonschema.Reflector)
	reflector.RequiredFromJSONSchemaTags = true
	schemas := make(map[string]*jsonschema.Schema)
	for name, typ := range typesToProcess {
		schemas[name] = reflector.Reflect(typ)
	}

	paths := make(map[string]*PathItem)
	openapiPathRegex := regexp.MustCompile(`{([^{}]+)}`)
	for _, route := range routes {
		openapiPath := openapiPathRegex.ReplaceAllString(route.Path, "{$1}")
		if !strings.HasPrefix(openapiPath, "/") {
			openapiPath = "/" + openapiPath
		}
		if _, ok := paths[openapiPath]; !ok {
			paths[openapiPath] = &PathItem{}
		}
		operation := &Operation{
			Summary:     route.Summary,
			Description: route.Description,
			OperationID: handlerToFuncName(route.GoHandlerName),
			Tags:        route.Tags,
			Responses:   make(map[string]Response),
		}
		for _, pName := range route.PathParams {
			operation.Parameters = append(operation.Parameters, Parameter{
				Name:        pName,
				In:          "path",
				Required:    true,
				Description: fmt.Sprintf("The ID for the %s.", pName),
				Schema:      &jsonschema.Schema{Type: "string"},
			})
		}
		if route.InputType != "" {
			// inputSchema := schemas[route.InputType]
			if route.HasInputBody {
				operation.RequestBody = &RequestBody{
					Required: true,
					Content: map[string]Content{
						"application/json": {Schema: Ref{Ref: "#/components/schemas/" + route.InputType}},
					},
				}
			} else {
				// if inputSchema.Properties != nil {
				// 	inputSchema.Properties.Range(func(key string, prop *jsonschema.Schema) bool {
				// 		operation.Parameters = append(operation.Parameters, Parameter{
				// 			Name:     key,
				// 			In:       "query",
				// 			Required: isRequired(key, inputSchema.Required),
				// 			Schema:   prop,
				// 		})
				// 		return true
				// 	})
				// }
			}
		}
		if route.OutputType != "" && route.OutputType != "any" {
			operation.Responses["200"] = Response{
				Description: "Successful response",
				Content: map[string]Content{
					"application/json": {Schema: Ref{Ref: "#/components/schemas/" + route.OutputType}},
				},
			}
		} else {
			operation.Responses["200"] = Response{Description: "Successful response without a body"}
		}
		operation.Responses["default"] = Response{
			Description: "An unexpected error occurred.",
			Content: map[string]Content{
				"application/json": {Schema: Ref{Ref: "#/components/schemas/APIError"}},
			},
		}
		switch strings.ToUpper(route.Method) {
		case "GET":
			paths[openapiPath].Get = operation
		case "POST":
			paths[openapiPath].Post = operation
		case "PUT":
			paths[openapiPath].Put = operation
		case "PATCH":
			paths[openapiPath].Patch = operation
		case "DELETE":
			paths[openapiPath].Delete = operation
		}
	}
	doc := OpenAPI{
		OpenAPI: "3.0.1",
		Info: Info{
			Title:       "credimi ðŸ‘€ API Gateway",
			Version:     "1.4.0",
			Description: `credimi API Gateway for managing EUDI-ARF compliance checks...`,
			Contact: Contact{
				Name:  "credimi Support",
				Email: "support@forkbomb.eu",
				URL:   "https://forkbomb.solutions",
			},
		},
		Servers: []Server{
			{URL: "https://demo.credimi.io", Description: "Demo server"},
			{URL: "http://localhost:8090/", Description: "Localhost server"},
		},
		Paths: paths,
		Components: Components{
			Schemas: schemas,
		},
	}

	// --- (Stage 2: The JSON Bridge for Clean Output) ---

	// 1. Marshal the struct to JSON. This respects all the `json:",omitempty"`
	//    tags in the jsonschema library, creating a clean intermediate structure.
	jsonBytes, err := json.Marshal(doc)
	if err != nil {
		log.Fatalf("FATAL: Failed to marshal intermediate JSON: %v", err)
	}

	// 2. Unmarshal the clean JSON into a generic interface{}. This strips all
	//    the struct field information and leaves us with pure map[string]interface{} data.
	var genericData interface{}
	if err := json.Unmarshal(jsonBytes, &genericData); err != nil {
		log.Fatalf("FATAL: Failed to unmarshal intermediate JSON: %v", err)
	}

	// 3. Marshal the clean, generic data into YAML.
	outputPath := "../docs/public/API/openapi.yml"
	var buf bytes.Buffer
	encoder := yaml.NewEncoder(&buf)
	encoder.SetIndent(2)

	if err := encoder.Encode(genericData); err != nil {
		log.Fatalf("FATAL: Failed to marshal final YAML: %v", err)
	}

	if err := os.WriteFile(outputPath, buf.Bytes(), 0644); err != nil {
		log.Fatalf("FATAL: Failed to write OpenAPI file '%s': %v", err)
	}
	log.Printf("âœ… OpenAPI YAML documentation successfully generated at: %s", outputPath)
}


// =================================================================
// =============== HELPER FUNCTIONS 
// =================================================================

func getFuncName(i interface{}) string {
	return runtime.FuncForPC(reflect.ValueOf(i).Pointer()).Name()
}
func handlerToFuncName(fullHandlerName string) string {
	parts := strings.Split(fullHandlerName, ".")
	name := parts[len(parts)-1]
	name = strings.TrimPrefix(name, "Handle")
	if name == "" {
		return "unnamedRoute"
	}
	return strings.ToLower(name[:1]) + name[1:]
}
func extractPathParams(path string) []string {
	var params []string
	re := regexp.MustCompile(`{([^{}]+)}`)
	matches := re.FindAllStringSubmatch(path, -1)
	for _, match := range matches {
		if len(match) > 1 {
			params = append(params, match[1])
		}
	}
	return params
}
func isRequired(field string, requiredFields []string) bool {
	for _, req := range requiredFields {
		if req == field {
			return true
		}
	}
	return false
}