// SPDX-FileCopyrightText: 2025 Forkbomb BV
//
// SPDX-License-Identifier: AGPL-3.0-or-later

// Generated by api-generator; DO NOT EDIT.
/* eslint-disable */
import { z } from "zod";
import type PocketBase from "pocketbase";

// =================================================================
// =============== SCHEMAS, TYPES & ERROR HANDLING
// =================================================================

export const TerminateMyCheckRunResponseSchema = z.object({
  message: z.string().min(1),
  checkId: z.string().min(1),
  runId: z.string().min(1),
  status: z.string().min(1),
  time: z.string().min(1),
  namespace: z.string().min(1),
})
export type TerminateMyCheckRunResponse = z.infer<typeof TerminateMyCheckRunResponseSchema>

export const AuthenticateApiKeyResponseSchema = z.object({
  message: z.string(),
  token: z.string(),
})
export type AuthenticateApiKeyResponse = z.infer<typeof AuthenticateApiKeyResponseSchema>

export const APIErrorSchema = z.object({
  Code: z.number(),
  Domain: z.string(),
  Reason: z.string(),
  Message: z.string(),
})
export type APIError = z.infer<typeof APIErrorSchema>

export const MessageStateSchema = z.object({
  state: z.string(),
  details: z.string(),
})
export type MessageState = z.infer<typeof MessageStateSchema>

export const MostRecentWorkflowVersionStampSchema = z.object({
  workflowVersionTimestamp: z.string(),
  useVersioning: z.boolean().optional(),
})
export type MostRecentWorkflowVersionStamp = z.infer<typeof MostRecentWorkflowVersionStampSchema>

export const PayloadSchema = z.object({
  metadata: z.record(z.string(), z.string()).optional(),
  data: z.string().optional(),
})
export type Payload = z.infer<typeof PayloadSchema>

export const MemoSchema = z.object({
  fields: z.record(z.string(), PayloadSchema).optional(),
})
export type Memo = z.infer<typeof MemoSchema>

export const WorkflowIdentifierSchema = z.object({
  workflowId: z.string().min(1),
  runId: z.string().optional(),
})
export type WorkflowIdentifier = z.infer<typeof WorkflowIdentifierSchema>

export const PendingChildrenSchema = z.object({
  workflowId: z.string().min(1),
  runId: z.string().optional(),
  workflowTypeName: z.string().min(1),
  initiatedId: z.string().min(1),
  parentClosePolicy: z.string().optional(),
})
export type PendingChildren = z.infer<typeof PendingChildrenSchema>

export type Failure = {
  message?: string | undefined,
  source?: string | undefined,
  stackTrace?: string | undefined,
  cause?: Failure | undefined,
  failureInfo?: Record<string, string> | undefined,
}
const FailureSchemaShape = {
  message: z.string().optional(),
  source: z.string().optional(),
  stackTrace: z.string().optional(),
  cause: z.lazy(() => FailureSchema).optional(),
  failureInfo: z.record(z.string(), z.string()).optional(),
}
export const FailureSchema: z.ZodType<Failure> = z.object(FailureSchemaShape)

export const PendingNexusOperationSchema = z.object({
  endpoint: z.string().min(1),
  service: z.string().min(1),
  operation: z.string().min(1),
  operationId: z.string().min(1),
  scheduledEventId: z.string().min(1),
  state: z.string().min(1),
  attempt: z.number().optional(),
  nextAttemptScheduleTime: z.string().optional(),
  lastAttemptCompleteTime: z.string().optional(),
  lastAttemptFailure: FailureSchema.optional(),
})
export type PendingNexusOperation = z.infer<typeof PendingNexusOperationSchema>

export const ActivityTypeSchema = z.object({
  name: z.string().min(1),
})
export type ActivityType = z.infer<typeof ActivityTypeSchema>

export const PendingActivityInfoSchema = z.object({
  activityId: z.string().min(1),
  activityType: ActivityTypeSchema,
  state: z.string().min(1),
  heartbeatDetails: PayloadSchema.array().optional().nullable(),
  lastHeartbeatTime: z.string().optional(),
  lastStartedTime: z.string().optional(),
  attempt: z.number().optional(),
  maximumAttempts: z.number().optional(),
  scheduledTime: z.string().optional(),
  expirationTime: z.string().optional(),
  lastFailure: FailureSchema.optional(),
  lastWorkerIdentity: z.string().optional(),
  assignedBuildId: z.string().optional(),
})
export type PendingActivityInfo = z.infer<typeof PendingActivityInfoSchema>

export const PendingWorkflowTaskInfoSchema = z.object({
  state: z.string().optional(),
  scheduledTime: z.string().optional(),
  originalScheduledTime: z.string().optional(),
  startedTime: z.string().optional(),
  attempt: z.number().optional(),
  lastFailure: FailureSchema.optional(),
})
export type PendingWorkflowTaskInfo = z.infer<typeof PendingWorkflowTaskInfoSchema>

export const DurationSchema = z.object({
  seconds: z.number().optional(),
  nanos: z.number().optional(),
})
export type Duration = z.infer<typeof DurationSchema>

export const CallbackInfoSchema = z.object({
  callback: PayloadSchema.optional(),
  registrationTime: z.string().optional(),
})
export type CallbackInfo = z.infer<typeof CallbackInfoSchema>

export const CallbackSchema = z.object({
  trigger: CallbackInfoSchema.optional(),
  publicInfo: CallbackInfoSchema.optional(),
  state: z.string().optional(),
  attempt: z.number().optional(),
  lastAttemptCompleteTime: z.string().optional(),
  lastAttemptFailure: FailureSchema.optional(),
  nextAttemptScheduleTime: z.string().optional(),
})
export type Callback = z.infer<typeof CallbackSchema>

export const CallbacksSchema = z.object({
  callbacks: CallbackSchema.array().optional(),
})
export type Callbacks = z.infer<typeof CallbacksSchema>

export const VersioningInfoSchema = z.object({
  useVersioning: z.boolean().optional(),
})
export type VersioningInfo = z.infer<typeof VersioningInfoSchema>

export const WorkflowExecutionSchema = z.object({
  name: z.string(),
  id: z.string(),
  runId: z.string(),
  startTime: z.string(),
  endTime: z.string(),
  executionTime: z.string(),
  status: MessageStateSchema,
  taskQueue: z.string().optional(),
  historyEvents: z.string(),
  historySizeBytes: z.string(),
  mostRecentWorkerVersionStamp: MostRecentWorkflowVersionStampSchema.optional(),
  assignedBuildId: z.string().optional(),
  searchAttributes: z.record(z.string(), z.any()).optional().nullable(),
  memo: MemoSchema.optional(),
  rootExecution: WorkflowIdentifierSchema.optional(),
  pendingChildren: PendingChildrenSchema.array().optional(),
  pendingNexusOperations: PendingNexusOperationSchema.array().optional(),
  pendingActivities: PendingActivityInfoSchema.array().optional(),
  pendingWorkflowTask: PendingWorkflowTaskInfoSchema.optional(),
  stateTransitionCount: z.string(),
  parentNamespaceId: z.string().optional(),
  parent: WorkflowIdentifierSchema.optional(),
  url: z.string(),
  isRunning: z.boolean(),
  defaultWorkflowTaskTimeout: DurationSchema.optional(),
  canBeTerminated: z.boolean(),
  callbacks: CallbacksSchema.optional(),
  versioningInfo: VersioningInfoSchema.optional(),
  summary: PayloadSchema.optional(),
  details: PayloadSchema.optional(),
})
export type WorkflowExecution = z.infer<typeof WorkflowExecutionSchema>

export const ListMyCheckRunsResponseSchema = z.object({
  executions: WorkflowExecutionSchema.array(),
})
export type ListMyCheckRunsResponse = z.infer<typeof ListMyCheckRunsResponseSchema>

export const CancelMyCheckRunResponseSchema = z.object({
  message: z.string().min(1),
  checkId: z.string().min(1),
  runId: z.string().min(1),
  status: z.string().min(1),
  time: z.string().min(1),
  namespace: z.string().min(1),
})
export type CancelMyCheckRunResponse = z.infer<typeof CancelMyCheckRunResponseSchema>

export const ExportDataSchema = z.object({
  checkId: z.string().min(1),
  runId: z.string().min(1),
  input: z.record(z.string(), z.any()),
  config: z.record(z.string(), z.any()),
})
export type ExportData = z.infer<typeof ExportDataSchema>

export const ExportMyCheckRunResponseSchema = z.object({
  export: ExportDataSchema,
})
export type ExportMyCheckRunResponse = z.infer<typeof ExportMyCheckRunResponseSchema>

export const ChecksLogsResponseSchema = z.object({
  channel: z.string().min(1),
  workflow_id: z.string().min(1),
  run_id: z.string().min(1),
  message: z.string().min(1),
  status: z.string().min(1),
  time: z.string().min(1),
  namespace: z.string().min(1),
})
export type ChecksLogsResponse = z.infer<typeof ChecksLogsResponseSchema>

export const GenerateApiKeyRequestSchema = z.object({
  name: z.string().min(1),
})
export type GenerateApiKeyRequest = z.infer<typeof GenerateApiKeyRequestSchema>

export const GenerateApiKeyResponseSchema = z.object({
  api_key: z.string(),
})
export type GenerateApiKeyResponse = z.infer<typeof GenerateApiKeyResponseSchema>

export const ListMyChecksResponseSchema = z.object({
  executions: WorkflowExecutionSchema.array(),
})
export type ListMyChecksResponse = z.infer<typeof ListMyChecksResponseSchema>

export const WorkflowExecutionInfoSchema = z.object({
  name: z.string(),
  id: z.string(),
  runId: z.string(),
  status: z.string(),
  stateTransitionCount: z.string(),
  startTime: z.string(),
  closeTime: z.string(),
  executionTime: z.string(),
  historySizeBytes: z.string(),
  historyLength: z.string(),
  assignedBuildId: z.string(),
  searchAttributes: z.record(z.string(), z.any()).optional().nullable(),
  memo: MemoSchema.optional(),
  versioningInfo: VersioningInfoSchema.optional(),
})
export type WorkflowExecutionInfo = z.infer<typeof WorkflowExecutionInfoSchema>

export const TaskQueueSchema = z.object({
  name: z.string().min(1),
  kind: z.string().optional(),
  normalName: z.string().optional(),
})
export type TaskQueue = z.infer<typeof TaskQueueSchema>

export const UserMetadataSchema = z.object({
  summary: PayloadSchema.optional(),
  details: PayloadSchema.optional(),
})
export type UserMetadata = z.infer<typeof UserMetadataSchema>

export const WorkflowExecutionConfigWithMetadataSchema = z.object({
  taskQueue: TaskQueueSchema.optional(),
  workflowExecutionTimeout: DurationSchema.optional(),
  workflowRunTimeout: DurationSchema.optional(),
  defaultWorkflowTaskTimeout: DurationSchema.optional(),
  userMetadata: UserMetadataSchema.optional(),
})
export type WorkflowExecutionConfigWithMetadata = z.infer<typeof WorkflowExecutionConfigWithMetadataSchema>

export const GetMyCheckRunResponseSchema = z.object({
  workflowExecutionInfo: WorkflowExecutionInfoSchema.optional(),
  pendingActivities: PendingActivityInfoSchema.array().optional(),
  pendingChildren: PendingChildrenSchema.array().optional(),
  pendingNexusOperations: PendingNexusOperationSchema.array().optional(),
  executionConfig: WorkflowExecutionConfigWithMetadataSchema.optional(),
  callbacks: CallbacksSchema.optional(),
  pendingWorkflowTask: PendingWorkflowTaskInfoSchema.optional(),
})
export type GetMyCheckRunResponse = z.infer<typeof GetMyCheckRunResponseSchema>

export const GetMyCheckRunHistoryResponseSchema = z.object({
  history: z.record(z.string(), z.any()).array(),
  count: z.number().refine((val) => val !== 0),
  time: z.string().min(1),
  checkId: z.string().min(1),
  runId: z.string().min(1),
  namespace: z.string().min(1),
})
export type GetMyCheckRunHistoryResponse = z.infer<typeof GetMyCheckRunHistoryResponseSchema>

export const ReRunCheckRequestSchema = z.object({
  config: z.record(z.string(), z.any()).nullable(),
})
export type ReRunCheckRequest = z.infer<typeof ReRunCheckRequestSchema>

export const ReRunCheckResponseSchema = z.object({
  workflow_id: z.string().min(1),
  run_id: z.string().min(1),
})
export type ReRunCheckResponse = z.infer<typeof ReRunCheckResponseSchema>



/**
 * CredimiClientError is a custom error class for typed API errors.
 */
export class CredimiClientError extends Error {
    public readonly data: APIError;

    constructor(errorData: APIError) {
        super(errorData.Message || 'An API error occurred');
        this.name = 'CredimiClientError';
        this.data = errorData;
    }
}

// =================================================================
// =============== API CLIENT CLASS
// =================================================================

/** * ClientOptions interface for optional request parameters.
 */
export interface ClientOptions {
  body?: any;
  headers?: { [key: string]: string };
}
/**
 * Interface for options when sending requests.
 */
export interface SendOptions extends ClientOptions {
	method?: 'GET' | 'POST' | 'PUT' | 'DELETE';
	query?: { [key: string]: any };
}

export class CredimiClient {
    constructor(public pb: PocketBase) {}

    /**
     * Get a list of all checks for the authenticated user
	 * List all checks for the authenticated user
     * @method GET
     * @path /api/my/checks
     */
    async listMyChecks( options?: ClientOptions ): Promise<ListMyChecksResponse> {
        const path = `/api/my/checks`;

        var opt: SendOptions = { method: "GET" };

        
		if (options) {
			opt = { ...opt, ...options };
		}

        try {
            const result = await this.pb.send(path, opt);
						return ListMyChecksResponseSchema.parse(result);
        } catch (error: any) {
            if (error && error.data) {
                const parsedError = APIErrorSchema.safeParse(error.data);
                if (parsedError.success) {
                    throw new CredimiClientError(parsedError.data);
                }
            }
            throw error;
        }
    }

    /**
     * Get a list of all runs for a specific check
	 * List all runs for a specific check
     * @method GET
     * @path /api/my/checks/{checkId}/runs
     */
    async listMyCheckRuns(input: { checkId: string }, options?: ClientOptions ): Promise<ListMyCheckRunsResponse> {
        const path = `/api/my/checks/${input.checkId}/runs`;

        var opt: SendOptions = { method: "GET" };

        
		if (options) {
			opt = { ...opt, ...options };
		}

        try {
            const result = await this.pb.send(path, opt);
						return ListMyCheckRunsResponseSchema.parse(result);
        } catch (error: any) {
            if (error && error.data) {
                const parsedError = APIErrorSchema.safeParse(error.data);
                if (parsedError.success) {
                    throw new CredimiClientError(parsedError.data);
                }
            }
            throw error;
        }
    }

    /**
     * Get details of a specific run for a check
	 * Get details of a specific run for a check
     * @method GET
     * @path /api/my/checks/{checkId}/runs/{runId}
     */
    async getMyCheckRun(input: { checkId: string, runId: string }, options?: ClientOptions ): Promise<GetMyCheckRunResponse> {
        const path = `/api/my/checks/${input.checkId}/runs/${input.runId}`;

        var opt: SendOptions = { method: "GET" };

        
		if (options) {
			opt = { ...opt, ...options };
		}

        try {
            const result = await this.pb.send(path, opt);
						return GetMyCheckRunResponseSchema.parse(result);
        } catch (error: any) {
            if (error && error.data) {
                const parsedError = APIErrorSchema.safeParse(error.data);
                if (parsedError.success) {
                    throw new CredimiClientError(parsedError.data);
                }
            }
            throw error;
        }
    }

    /**
     * Get the history of events for a specific run of a check
	 * Get the history of events for a specific run of a check
     * @method GET
     * @path /api/my/checks/{checkId}/runs/{runId}/history
     */
    async getMyCheckRunHistory(input: { checkId: string, runId: string }, options?: ClientOptions ): Promise<GetMyCheckRunHistoryResponse> {
        const path = `/api/my/checks/${input.checkId}/runs/${input.runId}/history`;

        var opt: SendOptions = { method: "GET" };

        
		if (options) {
			opt = { ...opt, ...options };
		}

        try {
            const result = await this.pb.send(path, opt);
						return GetMyCheckRunHistoryResponseSchema.parse(result);
        } catch (error: any) {
            if (error && error.data) {
                const parsedError = APIErrorSchema.safeParse(error.data);
                if (parsedError.success) {
                    throw new CredimiClientError(parsedError.data);
                }
            }
            throw error;
        }
    }

    /**
     * Re-run a specific check run
	 * Re-run a specific check run
     * @method POST
     * @path /api/my/checks/{checkId}/runs/{runId}/rerun
     */
    async rerunMyCheck(input: ReRunCheckRequest & { checkId: string, runId: string }, options?: ClientOptions ): Promise<ReRunCheckResponse> {
        const path = `/api/my/checks/${input.checkId}/runs/${input.runId}/rerun`;

        var opt: SendOptions = { method: "POST" };

        opt.body = ReRunCheckRequestSchema.parse(input);
		if (options) {
			opt = { ...opt, ...options };
		}

        try {
            const result = await this.pb.send(path, opt);
						return ReRunCheckResponseSchema.parse(result);
        } catch (error: any) {
            if (error && error.data) {
                const parsedError = APIErrorSchema.safeParse(error.data);
                if (parsedError.success) {
                    throw new CredimiClientError(parsedError.data);
                }
            }
            throw error;
        }
    }

    /**
     * Cancel a specific check run
	 * Cancel a specific check run
     * @method POST
     * @path /api/my/checks/{checkId}/runs/{runId}/cancel
     */
    async cancelMyCheckRun(input: { checkId: string, runId: string }, options?: ClientOptions ): Promise<CancelMyCheckRunResponse> {
        const path = `/api/my/checks/${input.checkId}/runs/${input.runId}/cancel`;

        var opt: SendOptions = { method: "POST" };

        
		if (options) {
			opt = { ...opt, ...options };
		}

        try {
            const result = await this.pb.send(path, opt);
						return CancelMyCheckRunResponseSchema.parse(result);
        } catch (error: any) {
            if (error && error.data) {
                const parsedError = APIErrorSchema.safeParse(error.data);
                if (parsedError.success) {
                    throw new CredimiClientError(parsedError.data);
                }
            }
            throw error;
        }
    }

    /**
     * Export a specific check run
	 * Export a specific check run
     * @method GET
     * @path /api/my/checks/{checkId}/runs/{runId}/export
     */
    async exportMyCheckRun(input: { checkId: string, runId: string }, options?: ClientOptions ): Promise<ExportMyCheckRunResponse> {
        const path = `/api/my/checks/${input.checkId}/runs/${input.runId}/export`;

        var opt: SendOptions = { method: "GET" };

        
		if (options) {
			opt = { ...opt, ...options };
		}

        try {
            const result = await this.pb.send(path, opt);
						return ExportMyCheckRunResponseSchema.parse(result);
        } catch (error: any) {
            if (error && error.data) {
                const parsedError = APIErrorSchema.safeParse(error.data);
                if (parsedError.success) {
                    throw new CredimiClientError(parsedError.data);
                }
            }
            throw error;
        }
    }

    /**
     * Start or Stop logs for a specific check run
	 * Start or Stop logs for a specific check run and get the log channel
     * @method GET
     * @path /api/my/checks/{checkId}/runs/{runId}/logs
     */
    async myCheckLogs(input: { checkId: string, runId: string } & { action?: string }, options?: ClientOptions ): Promise<ChecksLogsResponse> {
        const path = `/api/my/checks/${input.checkId}/runs/${input.runId}/logs`;

        var opt: SendOptions = { method: "GET" };

        let query: { [key: string]: any } = {};
        
        // Add query search attributes
        if (input.action !== undefined) {
            query['action'] = input.action;
        }
        
        opt.query = query;
		if (options) {
			opt = { ...opt, ...options };
		}

        try {
            const result = await this.pb.send(path, opt);
						return ChecksLogsResponseSchema.parse(result);
        } catch (error: any) {
            if (error && error.data) {
                const parsedError = APIErrorSchema.safeParse(error.data);
                if (parsedError.success) {
                    throw new CredimiClientError(parsedError.data);
                }
            }
            throw error;
        }
    }

    /**
     * Terminate a specific check run
	 * Terminate a specific check run
     * @method POST
     * @path /api/my/checks/{checkId}/runs/{runId}/terminate
     */
    async terminateMyCheckRun(input: { checkId: string, runId: string }, options?: ClientOptions ): Promise<TerminateMyCheckRunResponse> {
        const path = `/api/my/checks/${input.checkId}/runs/${input.runId}/terminate`;

        var opt: SendOptions = { method: "POST" };

        
		if (options) {
			opt = { ...opt, ...options };
		}

        try {
            const result = await this.pb.send(path, opt);
						return TerminateMyCheckRunResponseSchema.parse(result);
        } catch (error: any) {
            if (error && error.data) {
                const parsedError = APIErrorSchema.safeParse(error.data);
                if (parsedError.success) {
                    throw new CredimiClientError(parsedError.data);
                }
            }
            throw error;
        }
    }

    /**
     * Generate API Key
	 * Generate a new API key for the authenticated user.
     * @method POST
     * @path /api/apikey/generate
     */
    async generateApiKey(input: GenerateApiKeyRequest, options?: ClientOptions ): Promise<GenerateApiKeyResponse> {
        const path = `/api/apikey/generate`;

        var opt: SendOptions = { method: "POST" };

        opt.body = GenerateApiKeyRequestSchema.parse(input);
		if (options) {
			opt = { ...opt, ...options };
		}

        try {
            const result = await this.pb.send(path, opt);
						return GenerateApiKeyResponseSchema.parse(result);
        } catch (error: any) {
            if (error && error.data) {
                const parsedError = APIErrorSchema.safeParse(error.data);
                if (parsedError.success) {
                    throw new CredimiClientError(parsedError.data);
                }
            }
            throw error;
        }
    }

    /**
     * Authenticate API Key
	 * Authenticate an API key and return Bearer token
     * @method GET
     * @path /api/apikey/authenticate
     */
    async authenticateApiKey( options?: ClientOptions ): Promise<AuthenticateApiKeyResponse> {
        const path = `/api/apikey/authenticate`;

        var opt: SendOptions = { method: "GET" };

        
		if (options) {
			opt = { ...opt, ...options };
		}

        try {
            const result = await this.pb.send(path, opt);
						return AuthenticateApiKeyResponseSchema.parse(result);
        } catch (error: any) {
            if (error && error.data) {
                const parsedError = APIErrorSchema.safeParse(error.data);
                if (parsedError.success) {
                    throw new CredimiClientError(parsedError.data);
                }
            }
            throw error;
        }
    }

}
