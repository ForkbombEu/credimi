// SPDX-FileCopyrightText: 2025 Forkbomb BV
//
// SPDX-License-Identifier: AGPL-3.0-or-later

// Generated by api-generator; DO NOT EDIT.
/* eslint-disable */
import { z } from "zod";
import type PocketBase from "pocketbase";

// =================================================================
// =============== SCHEMAS, TYPES & ERROR HANDLING
// =================================================================

export const MessageStateSchema = z.object({
  state: z.string(),
  details: z.string(),
})
export type MessageState = z.infer<typeof MessageStateSchema>

export const WorkflowExecutionSchema = z.object({
  name: z.string(),
  id: z.string(),
  runId: z.string(),
  startTime: z.string(),
  endTime: z.string(),
  executionTime: z.string(),
  status: MessageStateSchema,
  taskQueue: z.string().optional(),
  historyEvents: z.string(),
  historySizeBytes: z.string(),
  assignedBuildId: z.string().optional(),
  parentNamespaceId: z.string().optional(),
  url: z.string(),
  isRunning: z.boolean(),
  canBeTerminated: z.boolean(),
})
export type WorkflowExecution = z.infer<typeof WorkflowExecutionSchema>

export const ListMyCheckRunsOutputSchema = z.object({
  executions: WorkflowExecutionSchema.array().nullable(),
})
export type ListMyCheckRunsOutput = z.infer<typeof ListMyCheckRunsOutputSchema>

export const EventSchema = z.object({
  eventId: z.string(),
  eventType: z.string(),
  eventTime: z.string(),
  details: z.string(),
  attributes: z.string(),
})
export type Event = z.infer<typeof EventSchema>

export const GetMyCheckRunHistorySchema = z.object({
  history: EventSchema.array().nullable(),
  count: z.number(),
  time: z.string(),
  checkId: z.string(),
  runId: z.string(),
  namespace: z.string(),
})
export type GetMyCheckRunHistory = z.infer<typeof GetMyCheckRunHistorySchema>

export const ExportSchema = z.object({
  checkId: z.string(),
  runId: z.string(),
  input: z.record(z.string(), z.any()).nullable(),
  config: z.record(z.string(), z.any()).nullable(),
})
export type Export = z.infer<typeof ExportSchema>

export const ExportMyCheckRunSchema = z.object({
  export: ExportSchema,
})
export type ExportMyCheckRun = z.infer<typeof ExportMyCheckRunSchema>

export const ChecksLogsOutputSchema = z.object({
  channel: z.string(),
  workflow_id: z.string(),
  run_id: z.string(),
  message: z.string(),
  status: z.string(),
  time: z.string(),
  namespace: z.string(),
})
export type ChecksLogsOutput = z.infer<typeof ChecksLogsOutputSchema>

export const TerminateMyCheckRunOutputSchema = z.object({
  message: z.string(),
  workflow_id: z.string(),
  run_id: z.string(),
  status: z.string(),
  time: z.string(),
  namespace: z.string(),
})
export type TerminateMyCheckRunOutput = z.infer<typeof TerminateMyCheckRunOutputSchema>

export const GetMyCheckRunOutputSchema = z.object({
  workflow_execution: WorkflowExecutionSchema,
})
export type GetMyCheckRunOutput = z.infer<typeof GetMyCheckRunOutputSchema>

export const ReRunCheckInputSchema = z.object({
  config: z.record(z.string(), z.any()).nullable(),
})
export type ReRunCheckInput = z.infer<typeof ReRunCheckInputSchema>

export const ReRunCheckOutputSchema = z.object({
  workflow_id: z.string(),
  run_id: z.string(),
})
export type ReRunCheckOutput = z.infer<typeof ReRunCheckOutputSchema>

export const CancelMyCheckRunOutputSchema = z.object({
  message: z.string(),
  workflow_id: z.string(),
  run_id: z.string(),
  status: z.string(),
  time: z.string(),
  namespace: z.string(),
})
export type CancelMyCheckRunOutput = z.infer<typeof CancelMyCheckRunOutputSchema>

export const APIErrorSchema = z.object({
  Code: z.number(),
  Domain: z.string(),
  Reason: z.string(),
  Message: z.string(),
})
export type APIError = z.infer<typeof APIErrorSchema>

export const ListMyChecksOutputSchema = z.object({
  executions: WorkflowExecutionSchema.array().nullable(),
})
export type ListMyChecksOutput = z.infer<typeof ListMyChecksOutputSchema>



/**
 * CredimiClientError is a custom error class for typed API errors.
 */
export class CredimiClientError extends Error {
    public readonly data: APIError;

    constructor(errorData: APIError) {
        super(errorData.Message || 'An API error occurred');
        this.name = 'CredimiClientError';
        this.data = errorData;
    }
}

// =================================================================
// =============== API CLIENT CLASS
// =================================================================

/**
 * Interface for options when sending requests.
 */
interface SendOptions {
    method?: string;
    body?: any;
    params?: { [key: string]: any };
    [key: string]: any;
}

export class CredimiClient {
    constructor(public pb: PocketBase) {}

    /**
     * Get a list of all checks for the authenticated user
	 * List all checks for the authenticated user
     * @method GET
     * @path /api/my/checks
     */
    async listMyChecks(): Promise<ListMyChecksOutput> {
        const path = `/api/my/checks`;

        const options: SendOptions = { method: "GET" };

        

        try {
            const result = await this.pb.send(path, options);
						return ListMyChecksOutputSchema.parse(result);
        } catch (error: any) {
            if (error && error.data) {
                const parsedError = APIErrorSchema.safeParse(error.data);
                if (parsedError.success) {
                    throw new CredimiClientError(parsedError.data);
                }
            }
            throw error;
        }
    }

    /**
     * Get a list of all runs for a specific check
	 * List all runs for a specific check
     * @method GET
     * @path /api/my/checks/{checkId}/runs
     */
    async listMyCheckRuns(input: { checkId: string }): Promise<ListMyCheckRunsOutput> {
        const path = `/api/my/checks/${input.checkId}/runs`;

        const options: SendOptions = { method: "GET" };

        

        try {
            const result = await this.pb.send(path, options);
						return ListMyCheckRunsOutputSchema.parse(result);
        } catch (error: any) {
            if (error && error.data) {
                const parsedError = APIErrorSchema.safeParse(error.data);
                if (parsedError.success) {
                    throw new CredimiClientError(parsedError.data);
                }
            }
            throw error;
        }
    }

    /**
     * Get details of a specific run for a check
	 * Get details of a specific run for a check
     * @method GET
     * @path /api/my/checks/{checkId}/runs/{runId}
     */
    async getMyCheckRun(input: { checkId: string, runId: string }): Promise<GetMyCheckRunOutput> {
        const path = `/api/my/checks/${input.checkId}/runs/${input.runId}`;

        const options: SendOptions = { method: "GET" };

        

        try {
            const result = await this.pb.send(path, options);
						return GetMyCheckRunOutputSchema.parse(result);
        } catch (error: any) {
            if (error && error.data) {
                const parsedError = APIErrorSchema.safeParse(error.data);
                if (parsedError.success) {
                    throw new CredimiClientError(parsedError.data);
                }
            }
            throw error;
        }
    }

    /**
     * Get the history of events for a specific run of a check
	 * Get the history of events for a specific run of a check
     * @method GET
     * @path /api/my/checks/{checkId}/runs/{runId}/history
     */
    async getMyCheckRunHistory(input: { checkId: string, runId: string }): Promise<GetMyCheckRunHistory> {
        const path = `/api/my/checks/${input.checkId}/runs/${input.runId}/history`;

        const options: SendOptions = { method: "GET" };

        

        try {
            const result = await this.pb.send(path, options);
						return GetMyCheckRunHistorySchema.parse(result);
        } catch (error: any) {
            if (error && error.data) {
                const parsedError = APIErrorSchema.safeParse(error.data);
                if (parsedError.success) {
                    throw new CredimiClientError(parsedError.data);
                }
            }
            throw error;
        }
    }

    /**
     * Re-run a specific check run
	 * Re-run a specific check run
     * @method POST
     * @path /api/my/checks/{checkId}/runs/{runId}/rerun
     */
    async rerunMyCheck(input: ReRunCheckInput & { checkId: string, runId: string }): Promise<ReRunCheckOutput> {
        const path = `/api/my/checks/${input.checkId}/runs/${input.runId}/rerun`;

        const options: SendOptions = { method: "POST" };

        options.body = ReRunCheckInputSchema.parse(input);

        try {
            const result = await this.pb.send(path, options);
						return ReRunCheckOutputSchema.parse(result);
        } catch (error: any) {
            if (error && error.data) {
                const parsedError = APIErrorSchema.safeParse(error.data);
                if (parsedError.success) {
                    throw new CredimiClientError(parsedError.data);
                }
            }
            throw error;
        }
    }

    /**
     * Cancel a specific check run
	 * Cancel a specific check run
     * @method POST
     * @path /api/my/checks/{checkId}/runs/{runId}/cancel
     */
    async cancelMyCheckRun(input: { checkId: string, runId: string }): Promise<CancelMyCheckRunOutput> {
        const path = `/api/my/checks/${input.checkId}/runs/${input.runId}/cancel`;

        const options: SendOptions = { method: "POST" };

        

        try {
            const result = await this.pb.send(path, options);
						return CancelMyCheckRunOutputSchema.parse(result);
        } catch (error: any) {
            if (error && error.data) {
                const parsedError = APIErrorSchema.safeParse(error.data);
                if (parsedError.success) {
                    throw new CredimiClientError(parsedError.data);
                }
            }
            throw error;
        }
    }

    /**
     * Export a specific check run
	 * Export a specific check run
     * @method GET
     * @path /api/my/checks/{checkId}/runs/{runId}/export
     */
    async exportMyCheckRun(input: { checkId: string, runId: string }): Promise<ExportMyCheckRun> {
        const path = `/api/my/checks/${input.checkId}/runs/${input.runId}/export`;

        const options: SendOptions = { method: "GET" };

        

        try {
            const result = await this.pb.send(path, options);
						return ExportMyCheckRunSchema.parse(result);
        } catch (error: any) {
            if (error && error.data) {
                const parsedError = APIErrorSchema.safeParse(error.data);
                if (parsedError.success) {
                    throw new CredimiClientError(parsedError.data);
                }
            }
            throw error;
        }
    }

    /**
     * Start or Stop logs for a specific check run
	 * Start or Stop logs for a specific check run and get the log channel
     * @method GET
     * @path /api/my/checks/{checkId}/runs/{runId}/logs
     */
    async myCheckLogs(input: { checkId: string, runId: string }): Promise<ChecksLogsOutput> {
        const path = `/api/my/checks/${input.checkId}/runs/${input.runId}/logs`;

        const options: SendOptions = { method: "GET" };

        

        try {
            const result = await this.pb.send(path, options);
						return ChecksLogsOutputSchema.parse(result);
        } catch (error: any) {
            if (error && error.data) {
                const parsedError = APIErrorSchema.safeParse(error.data);
                if (parsedError.success) {
                    throw new CredimiClientError(parsedError.data);
                }
            }
            throw error;
        }
    }

    /**
     * Terminate a specific check run
	 * Terminate a specific check run
     * @method POST
     * @path /api/my/checks/{checkId}/runs/{runId}/terminate
     */
    async terminateMyCheckRun(input: { checkId: string, runId: string }): Promise<TerminateMyCheckRunOutput> {
        const path = `/api/my/checks/${input.checkId}/runs/${input.runId}/terminate`;

        const options: SendOptions = { method: "POST" };

        

        try {
            const result = await this.pb.send(path, options);
						return TerminateMyCheckRunOutputSchema.parse(result);
        } catch (error: any) {
            if (error && error.data) {
                const parsedError = APIErrorSchema.safeParse(error.data);
                if (parsedError.success) {
                    throw new CredimiClientError(parsedError.data);
                }
            }
            throw error;
        }
    }

}
